<html>
<body>
<h1>Automated 2-8 Site Model</h1>
<p> The files contained in the directory are for simulations of the Anderson-Hubbard model using an ensemble of 2,4,8 site systems. The program will calculate the density of states (DOS), generalized inverse participaion ratio (GIPR) and the filling.</p> 
<p>Information regarding the use and structure of the code can be found in this README file. The validation of this program was done, by comparing the results of the 2 and 4 site codes to the already validated stand alone versions as well as testing the 8 site version at the atomic limit and when there is no interactions (Anderson Model). At this moment (August 2015) a file outlining the validation process has not been completed.</p>
<p>Many of the equations used are found in the file <em>math&#95equations.pdf</em> in the parent directory <em>AHM-ED</em>. The directory <em>aux&#95programs</em> contains additional programs that were written. Information regarding each can be found at the top of each of their files.</p>
<p>The executable files of the programs concerning the manipulation of the data files (changing bin with or combining multiple files) have been added to the data folder for ease of use.</p>
<h3>1. Downloading files</h3>
<p>Fork the repository AH-onsite to your GitHub account if you have not already done so. If would do not wish to use GitHub the files can be individually downloaded. The files needed to create the executable are <em>routines.f90, main.f90, makefile, math.e, text.sh, lapack.f90</em>. If you plan on modifying the files and wanting the update the files on GitHub we highly recommend forking the repository (information on how to use GitHub to create your personal repository can be found in the README in the AH-onsite directory). </p>
<h3>2. Compilling and Running</h3>
This program is orgnized in a different way then the other codes due to the reason it can do ensembles of different system sizes (ensemble is only of one size but the size can be varied between simulations). Some variables are only declared for larger systems (notably Hamiltonian submatrices for fock states with 4+ up or down electrons are only used in 8 site). To deal with these issues the file <em>routines.f90</em> is rewritten depending on the size of systems you would like to use. The first line of the script file <em>text.sh</em> must be changed to the system size and the file when executed will output the file routines.f90 for that system. At this point it can be treated like the previous codes.</p>
<h4>Basic</h4>
<p>Open the file <em>text.sh</em> and change the first line to the system size you want. To make it's output be saved into the file <em>routines.f90</em> type: <strong>./text.sh > routines.f90</strong>. Sometimes it may tell you the script file is not executable, to make it an executable again type: <strong>chmod +x text.sh</strong>.</p>
<p>In the folder where the files are located type the command "<em>make</em>". This will compile the executable program. The executable is called <em>main.e</em> and it can be run using the command "<em>./main.e</em>". To remove any auxiliary files type "<em>make clean</em>".</p>
<p>To modify the input variables open main.f90 in a text editor. In the section labeled input parameters (line 25-33) modify values assigned to the variables. The description of each variable can be found in the comments beside it.
<h4>Advanced</h4>
<p>The compiller specified in the makefile is gfortran if you would like to use another compiller open the makefile in a text editor and set the variable <em>CC</em> to the compiller of your choice. To add flags to specify the optimization of the code, debugging or any other purposes append them to the CFLAGS variable in the makefile. Optimization -O0 is lowest and -O3 is highest. Currently the highest optimization (-03) is functional however if errors are encountered first lower the optimization.</p>
<p>The only library that needs to be linked is the LAPACK library (linear algebra package). If not already owned it can be downloaded <a href="http://www.netlib.org/lapack/#_lapack_version_3_5_0" target="_blank">here</a>.</p>
<p> To modify other aspects of the program read through the section <a href="#structure">Structure of the Program</a> in order to find the location of the feauture you would like to change.</p>
<h4>Runtime</h4>
<p>The code takes different amount of time based on the size of the systems in the ensemble and the size of the ensemble. The code runs at almost identical speeds on sharcnet as the desktop. The program takes approximately 5minutes to run 10 million 2site systems and 1.5minutes to run an ensemble of 100 000 four site systems. The 8 site version takes 1.5minutes to get to the start of the loops (this is the steps that contruct the lookup tables and hamiltonians) and then approximately 4minutes for each iteration. So to run an ensemble of only 1 system it takes approximately 5minutes and for 100 it takes 401 minutes.</p>
<h3>3. Data and Graphs</h3>
Previous data and graphs that have been created using this code can be found in the <em>data</em> directory. The graphs are stored as .agr files and can be opened using xmgrace. Some also have been saved in pdf format as well. The data files have names based on the parameters of the simulation that created them. The naming conventions of the files can be found in the README file of the <em>data</em> directory.</p> 
<p>At the top of the data files there contains information about the simulation that created the data as well as the filling of the DOS. Then there are three labeled columns. The first column is the frequency of each energy bin, the second is the DOS of that bin and the third is the GIPR.</p>
<h3 id="structure">4. Structure of Program</h3>
<h4>General</h4>
The file main.f90 contains the main program. This file is where the parameters are declared as well as any dependent variables that are only need in main.f90. The file routines.f90 contains the module <em>routines</em> which has all the main subroutines needed for the program. The file <em>lapack.f90</em> contains additional subroutines to facilitate the calling of LAPACK drivers. The program <em>math.f90</em> contains a subroutine needed when using the <em>text.sh</em> to make the output for <em>routines.f90</em>.At the top of routines.f90 any variables that are needed in both main.f90 and in the subroutines are declared so that the when the subroutine is called the variables do not need to be passed as arguments. The final executable is called main.e and it will output data to a file ending in <em>.dat</em>.</p>
<p>This section will descirbe the general flow of the program. To find the specifics on any particular section the source code is commented heavily. An important thing to realize is that the fock states used for the basis and throughout the code are represented in binary. For additional information regarding these check the top of the file <em>routines.f90</em>.</p>
<h4>Main Preperation</h4>
<p>A series of subroutines are called. The first seeds the random generator using the system clock (this is needed to assign the site potentials later on) then the file name for the output data is assigned and some lookup tables for the photo emmission specturm (PES) and inverse photo emmision specturm (IPES) of the basis are made. The off diagonal terms of the Hamiltonian submatrices are also calculated for they are independent of site potentials and thus remain constant. The output file name is also made from the parameters of the simulation.</p> 
<h4>Main Loop</h4>
<p>The program calls a subroutine (site_potentials) that will assign values for all the site potentials. These values are chosen from a uniform distribution bounded between -W/2 and W/2 (W is the disorder strength and a parameter of the program). </p>
<p>A subroutine (solve_hamiltonian1) is called in which the Hamiltonians on diagonal terms are entered and the lowest eigenvalue of each submatrix is calculated. This information is then given to the main program which finds the amount of up and down electrons in the many-body ground eigenstate (the lowest grand&#95potential). Another subroutine is then called (solve&#95hamiltons2) for each of the Hamiltonain submatrices that differ by one electron (these states can be transitioned to be a PE or IPE and therefore are relevant to the LDOS) and it solves them for all their eigenvalues and eigenvectors.</p>
<p>The program is now going to calculate the DOS and the GIPR. To do this it first needs to find the LDOS for each site. To calculate the LDOS it uses the equation defined in the file <em>math&#95equations.pdf</em>. It is comprised of many contributions from delta functions. The weight of each contribution is calculated by finding &#60Psi|c^{dagger}&#95{i,sigma}|Psi0&#62 and &#60Psi|c&#95{i,sigma}|Psi0&#62 where Psi is a many body eigenstate and Psi0 is the many-body ground eigenvector. The c^{dagger}&#95{i,sigma}|Psi0&#62 and c_{i,sigma}|Psi0&#62 vectors (hereby refered to as transformed ground vectors) are first calculated then the inner product of them with each of the other many body eigenstates is taken. The energy of the contribution is found by finding the difference between the eigenvalue of the many-body ground state and the many body eigenstate it's been inner producted with. The program will first find the transformed ground vectors then use their inner products with each many-body groundstate eigenvector to calculate the weight of the peaks and then make contributions to the LDOS at the calculated energies. It will then use the LDOS to calculate the DOS and GIPR.</p>
<p> In the main program now, the many-body ground state is multiplied by different matrix operators that cause a photo emmision (PE) or inverse photo emmision (IPE) of an electron from a particular site. Instead of directly doing a matrix multiplications the the PES and IPES lookup tables are used to find the new state each of the fock states in the basis (that the ground state vector is written in terms of) would become after that same operation (example: if the many-body ground state written in terms of the basis was 0.5A + 0.25B and after removing an electron from site 1 of both states A and B they would become the states in the basis E and F respectively, the new vector would be 0.5E + 0.25F). Using the lookup tables instead of direct matrix multiplicaiton substantialy decreases the memory needed and time for it to complete.</p>
<p>The LDOS for each site are now calculated. The weight of the each contribution is found by doing the inner product of each of the transformed many-body ground states (transformed by PES and IPES) with each of the other many-body eigenstates. The contribution of the spin up and spin down components are averaged (PES of up electron for site 1 is averages with PES of down electron from site 1). To find the energy of the contribution the programs find the difference between the lowest grand pontential and the grand pontential of the many-body eigenstate that caused the contribution. This difference is made negative if the many-body ground state was transformed with a IPES and positive if it was transformed with a PE.</p>
<p> The program then averages the LDOS contributions for each energy and then puts them into energy bins (in order to get a smooth graph) and makes a contribution to the DOS. The GIPR is also calculated at the same time using the LDOS.</p>
<h4>Final Calculations</h4>
<p>The total area underneath the DOS is calculated and then normalized to 1 and the filling is also calcuated at this time. The ensemble averages GIPR is also calcutated from the GIPR. The DOS and GIPR are outputted to the data file as well as the filling. The program is now complete.</p>
<h3>5. Current Status</h3>
<p>The program is currently functional (August 2015) however it runs into some issues when running the 8 site code when U=0. The issue is that the LAPACK routines SSYEVR does not finish sometimes for an unknown reason. If the driver is switch to SSYEV the error no longer occurs but this is too slow to do for all cases. A simple fix may be too change U to 0.001 when it is attempted to be set to 0. At this point multiple tests have been made and the programs seems to consistently work with U=0.01 but before this fix is made a large simulation with U=0.01 should be run and the results so be compared to the code for the Anderson Model (U=0). Other than this the program is fully operational. </p>
<h3>5. Future Modifications</h3>
The code could be easily modified to make the 4site version become a two band model of 2 site systems. The sections of the program that would need to be modified is the matrix (neighbours) that defines which sites are nearest neighbours and then add another similar matrix (maybe neighbours2) for another type of hopping that would have a different hopping integral.</p> 
<p>To then change the Hamiltonians the subroutines in <em>routines.f90</em> would need to be changed slighty. To add any off diagnal terms (the new type of hopping) you would need to add another couple loops that check which states can hop to each other in a similar way to the loops in the subroutines make_hamiltonian1() and add the code into the subroutine.</p>
<p>To take into account the coulomb interaction between different sites in the same band should be done by using a loop similar to that in solve_hamiltonian1() and then add it to solve&#95hamiltonian2().</p>
</body>
</html>
