<html>
<body>
<h1>4 Site Model</h1>
<p> The files contained in the directory are for simulations of the Anderson-Hubbard model using an ensemble of 4 site systems. The program will calculate the density of states (DOS), generalized inverse participaion ratio (GIPR) and the filling.</p> 
<p>Information regarding the use and structure of the code can be found in this README file. The directory <em>debugging</em> contains a pdf and .tex file (and images used in the files) that outlines the tests conducted and validation of the program. Many of the equations used are found in the file <em>math&#95equations.pdf</em> in the parent directory <em>AHM-ED</em>. The directory <em>aux&#95programs</em> contains additional program written during the debugging process that could be used for other purposes. Information regarding each can be found at the top of each of their files. The directory <em>matrices</em> contains excel documents outlining the basis and the hamiltonian submatrices.</p> 
<h3>1. Downloading files</h3>
<p>Fork the repository AH-onsite to your GitHub account if you have not already done so. If would do not wish to use GitHub the files can be individually downloaded. The files needed to create the executable are <em>routines.f90, main.f90, makefile</em>. If you plan on modifying the files and wanting the update the files on GitHub we highly recommend forking the repository (information on how to use GitHub to create your personal repository can be found in the README in the AH-onsite directory). </p>
<h3>2. Compilling and Running</h3>
<h4>Basic</h4>
<p>In the folder where the files are located type the command "<em>make</em>". This will compile the executable program. The executable is called <em>main.e</em> and it can be run using the command "<em>./main.e</em>". To remove any auxiliary files type "<em>make clean</em>".</p>
<p>To modify the input variables open main.f90 in a text editor. In the section labeled input parameters (line 25-33) modify values assigned to the variables. The description of each variable can be found in the comments beside it.
<h4>Advanced</h4>
<p>The compiller specified in the makefile is gfortran if you would like to use another compiller open the makefile in a text editor and set the variable <em>CC</em> to the compiller of your choice. To add flags to specify the optimization of the code, debugging or any other purposes append them to the CFLAGS variable in the makefile. Optimization -O0 is lowest and -O3 is highest. Currently the highest optimization (-03) is functional however if errors are encountered first lower the optimization.</p>
<p>The only library that needs to be linked is the LAPACK library (linear algebra package). If not already owned it can be downloaded <a href="http://www.netlib.org/lapack/#_lapack_version_3_5_0" target="_blank">here</a>.</p>
<p> To modify other aspects of the program read through the section <a href="#structure">Structure of the Program</a> in order to find the location of the feauture you would like to change.</p>
<h3>3. Data and Graphs</h3>
Previous data and graphs that have been created using this code can be found in the <em>data</em> directory. The graphs are stored as .agr files and can be opened using xmgrace. Some also have been saved in pdf format as well. The data files have names based on the parameters of the simulation that created them. The naming conventions of the files can be found in the README file of the <em>data</em> directory.</p> 
<p>At the top of the data files there contains information about the simulation that created the data as well as the filling of the DOS. Then there are three labeled columns. The first column is the frequency of each energy bin, the second is the DOS of that bin and the third is the GIPR.</p>
<p>On the top of the data files more information regarding the simulation can also be found including the filling.</p>
<h3 id="structure">4. Structure of Program</h3>
<h4>General</h4>
The file main.f90 contains the main program. This file is where the parameters are declared as well as any dependent variables that are only need in main.f90. The file routines.f90 contains the module <em>routines</em> which has all the subroutines need for the program. At the top of routines.f90 any variables that are needed in both main.f90 and in the subroutines are declared so that the when the subroutine is called the variables do not need to be passed as arguments. The final executable is called main.e and it will output data to a file ending in <em>.dat</em>.</p>
<h4>Main Preperation</h4>
<p>A series of subroutines are called. The first seeds the random generator using the system clock (this is needed to assign the site potentials later on) then the file name for the output data is assigned and some lookup tables for the photo emmission specturm (PES) and inverse photo emmision specturm (IPES) of the basis are made.</p>
<h4>Main Loop</h4>
<p>The program calls a subroutine (site_potentials) that will assign values for all the site potentials. These values are chosen from a uniform distribution bounded between -W/2 and W/2 (W is the disorder strength and a parameter of the program). </p>
<p>A subroutine is called in which the Hamiltonian is contructed and it's eigenvalues and eigenvectors are solved. The fock state used for the basis of the Hamiltonian are outline at the top of the file <em>main.f90</em>. It is sparse and block diagonal since the Hamiltonian conserves spin and the basis is orthogonal thereby only matrix elements in a row and column corresponding to two fock states (in the basis) with the same number of up and down electrons will be non-zero. The matrix is split into smaller submatrices of based on the amount of up and down electrons the fock states have. Each of these matrices are solved for their eigenvalues and eigenvectors using LAPACK (linear algebra package). From the eigenvalues the grand potentials are calculated (eigenvalue - (chemical potential)*(number of electrons)). The state with the lowest grand potential is the ground state and the corresponding vector is the many-body ground state. This a vector written in terms of the previously defined fock state basis.</p>
<p>The program is now going to calculate the DOS and the GIPR. To do this it first needs to find the LDOS for each site. To calculate the LDOS it uses the equation defined in the file <em>math_equations.pdf</em>. It is comprised of many contributions from delta functions. The weight of each contribution is calculated by finding &#60Psi|c^{dagger}_{i,sigma}|Psi0&#62 and &#60Psi|c_{i,sigma}|Psi0&#62 where Psi is a many body eigenstate and Psi0 is the many-body ground eigenvector. The c^{dagger}_{i,sigma}|Psi0&#62 and c_{i,sigma}|Psi0&#62 vectors (hereby refered to as transformed ground vectors) are first calculated then the inner product of them with each of the other many body eigenstates is taken. The energy of the contribution is found by finding the difference between the eigenvalue of the many-body ground state and the many body eigenstate it's been inner producted with. The program will first find the transformed ground vectors then use their inner products with each many-body groundstate eigenvector to calculate the weight of the peaks and then make contributions to the LDOS at the calculated energies. It will then use the LDOS to calculate the DOS and GIPR.</p>
<p> In the main program now, the many-body ground state is multiplied by different matrix operators that cause a photo emmision (PE) or inverse photo emmision (IPE) of an electron from a particular site. Instead of directly doing a matrix multiplications the the PES and IPES lookup tables are used to find the new state each of the fock states in the basis (that the ground state vector is written in terms of) would become after that same operation (example: if the many-body ground state written in terms of the basis was 0.5A + 0.25B and after removing an electron from site 1 of both states A and B they would become the states in the basis E and F respectively, the new vector would be 0.5E + 0.25F). Using the lookup tables instead of direct matrix multiplicaiton substantialy decreases the memory needed and time for it to complete.</p>
<p>The LDOS for each site are now calculated. The weight of the each contribution is found by doing the inner product of each of the transformed many-body ground states (transformed by PES and IPES) with each of the other many-body eigenstates. The contribution of the spin up and spin down components are averaged (PES of up electron for site 1 is averages with PES of down electron from site 1). To find the energy of the contribution the programs find the difference between the lowest grand pontential and the grand pontential of the many-body eigenstate that caused the contribution. This difference is made negative if the many-body ground state was transformed with a IPES and positive if it was transformed with a PE.</p>
<p> The program then averages the LDOS contributions for each energy and then puts them into energy bins (in order to get a smooth graph) and makes a contribution to the DOS. The GIPR is also calculated at the same time using the LDOS.</p>
<h4>Final Calculations</h4>
<p>The total area underneath the DOS is calculated and then normalized to 1 and the filling is also calcuated at this time. The ensemble averages GIPR is also calcutated from the GIPR. The DOS and GIPR are outputted to the data file as well as the filling. The program is now complete.</p>
</body>
</html>
